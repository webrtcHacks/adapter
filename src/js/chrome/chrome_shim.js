
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

import {
  log as logging,
  browserDetails
} from '../utils';

import shimGetUserMedia from './getusermedia';

function shimMediaStream() {
  window.MediaStream = window.MediaStream || window.webkitMediaStream;
}

function shimOnTrack() {
  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
      window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
      get: function() {
        return this._ontrack;
      },
      set: function(f) {
        var self = this;
        if (this._ontrack) {
          this.removeEventListener('track', this._ontrack);
          this.removeEventListener('addstream', this._ontrackpoly);
        }
        this.addEventListener('track', this._ontrack = f);
        this.addEventListener('addstream', this._ontrackpoly = function(e) {
          // onaddstream does not fire when a track is added to an existing
          // stream. But stream.onaddtrack is implemented so we use that.
          e.stream.addEventListener('addtrack', function(te) {
            var event = new Event('track');
            event.track = te.track;
            event.receiver = {track: te.track};
            event.streams = [e.stream];
            self.dispatchEvent(event);
          });
          e.stream.getTracks().forEach(function(track) {
            var event = new Event('track');
            event.track = track;
            event.receiver = {track: track};
            event.streams = [e.stream];
            this.dispatchEvent(event);
          }.bind(this));
        }.bind(this));
      }
    });
  }
}

function shimGetSendersWithDtmf() {
  if (typeof window === 'object' && window.RTCPeerConnection &&
      !('getSenders' in RTCPeerConnection.prototype) &&
      'createDTMFSender' in RTCPeerConnection.prototype) {
    RTCPeerConnection.prototype.getSenders = function() {
      return this._senders;
    };
    var origAddStream = RTCPeerConnection.prototype.addStream;
    var origRemoveStream = RTCPeerConnection.prototype.removeStream;

    RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      pc._senders = pc._senders || [];
      origAddStream.apply(pc, [stream]);
      stream.getTracks().forEach(function(track) {
        pc._senders.push({
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          }
        });
      });
    };

    RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      pc._senders = pc._senders || [];
      origRemoveStream.apply(pc, [stream]);
      stream.getTracks().forEach(function(track) {
        var sender = pc._senders.find(function(s) {
          return s.track === track;
        });
        if (sender) {
          pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
        }
      });
    };
  }
}

function shimSourceObject() {
  if (typeof window === 'object') {
    if (window.HTMLMediaElement &&
      !('srcObject' in window.HTMLMediaElement.prototype)) {
      // Shim the srcObject property, once, when HTMLMediaElement is found.
      Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
        get: function() {
          return this._srcObject;
        },
        set: function(stream) {
          var self = this;
          // Use _srcObject as a private property for this shim
          this._srcObject = stream;
          if (this.src) {
            URL.revokeObjectURL(this.src);
          }

          if (!stream) {
            this.src = '';
            return undefined;
          }
          this.src = URL.createObjectURL(stream);
          // We need to recreate the blob url when a track is added or
          // removed. Doing it manually since we want to avoid a recursion.
          stream.addEventListener('addtrack', function() {
            if (self.src) {
              URL.revokeObjectURL(self.src);
            }
            self.src = URL.createObjectURL(stream);
          });
          stream.addEventListener('removetrack', function() {
            if (self.src) {
              URL.revokeObjectURL(self.src);
            }
            self.src = URL.createObjectURL(stream);
          });
        }
      });
    }
  }
}

function shimPeerConnection() {
  // The RTCPeerConnection object.
  if (!window.RTCPeerConnection) {
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      // Translate iceTransportPolicy to iceTransports,
      // see https://code.google.com/p/webrtc/issues/detail?id=4869
      // this was fixed in M56 along with unprefixing RTCPeerConnection.
      logging('PeerConnection');
      if (pcConfig && pcConfig.iceTransportPolicy) {
        pcConfig.iceTransports = pcConfig.iceTransportPolicy;
      }

      return new webkitRTCPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if (webkitRTCPeerConnection.generateCertificate) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return webkitRTCPeerConnection.generateCertificate;
        }
      });
    }
  } else {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = RTCPeerConnection;
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            console.warn('RTCIceServer.url is deprecated! Use urls instead.');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
      get: function() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }

  var origGetStats = RTCPeerConnection.prototype.getStats;
  RTCPeerConnection.prototype.getStats = function(selector,
      successCallback, errorCallback) {
    var self = this;
    var args = arguments;

    // If selector is a function then we are in the old style stats so just
    // pass back the original getStats format to avoid breaking old users.
    if (arguments.length > 0 && typeof selector === 'function') {
      return origGetStats.apply(this, arguments);
    }

    // When spec-style getStats is supported, return those when called with
    // either no arguments or the selector argument is null.
    if (origGetStats.length === 0 && (arguments.length === 0 ||
        typeof arguments[0] !== 'function')) {
      return origGetStats.apply(this, []);
    }

    var fixChromeStats_ = function(response) {
      var standardReport = {};
      var reports = response.result();
      reports.forEach(function(report) {
        var standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          }[report.type] || report.type
        };
        report.names().forEach(function(name) {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });

      return standardReport;
    };

    // shim getStats with maplike support
    var makeMapStats = function(stats) {
      return new Map(Object.keys(stats).map(function(key) {
        return[key, stats[key]];
      }));
    };

    if (arguments.length >= 2) {
      var successCallbackWrapper_ = function(response) {
        args[1](makeMapStats(fixChromeStats_(response)));
      };

      return origGetStats.apply(this, [successCallbackWrapper_,
          arguments[0]]);
    }

    // promise-support
    return new Promise(function(resolve, reject) {
      origGetStats.apply(self, [
        function(response) {
          resolve(makeMapStats(fixChromeStats_(response)));
        }, reject]);
    }).then(successCallback, errorCallback);
  };

  // add promise support -- natively available in Chrome 51
  if (browserDetails.version < 51) {
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function() {
            var args = arguments;
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              nativeMethod.apply(self, [args[0], resolve, reject]);
            });
            if (args.length < 2) {
              return promise;
            }
            return promise.then(function() {
              args[1].apply(null, []);
            },
            function(err) {
              if (args.length >= 3) {
                args[2].apply(null, [err]);
              }
            });
          };
        });
  }

  // promise support for createOffer and createAnswer. Available (without
  // bugs) since M52: crbug/619289
  if (browserDetails.version < 52) {
    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = RTCPeerConnection.prototype[method];
      RTCPeerConnection.prototype[method] = function() {
        var self = this;
        if (arguments.length < 1 || (arguments.length === 1 &&
            typeof arguments[0] === 'object')) {
          var opts = arguments.length === 1 ? arguments[0] : undefined;
          return new Promise(function(resolve, reject) {
            nativeMethod.apply(self, [resolve, reject, opts]);
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });
  }

  // shim implicit creation of RTCSessionDescription/RTCIceCandidate
  ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
      .forEach(function(method) {
        var nativeMethod = RTCPeerConnection.prototype[method];
        RTCPeerConnection.prototype[method] = function() {
          arguments[0] = new ((method === 'addIceCandidate') ?
              RTCIceCandidate : RTCSessionDescription)(arguments[0]);
          return nativeMethod.apply(this, arguments);
        };
      });

  // support for addIceCandidate(null or undefined)
  var nativeAddIceCandidate =
      RTCPeerConnection.prototype.addIceCandidate;
  RTCPeerConnection.prototype.addIceCandidate = function() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}

export {
  shimMediaStream,
  shimOnTrack,
  shimGetSendersWithDtmf,
  shimSourceObject,
  shimPeerConnection,
  shimGetUserMedia
};
